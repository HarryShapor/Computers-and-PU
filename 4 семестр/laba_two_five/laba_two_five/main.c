#include <avr/io.h> //библиотека с логическими именами портов ввода/вывода
#include <avr/interrupt.h> //библиотека прерываний
unsigned char x = 0x00;	//переменная для угла поворота
ISR(TIMER1_COMPA_vect)	//прерывание таймера 1 по совпадению с A
{
	if (x >= 0xB4) //сравнение с пределом диапазона
	{
		TCCR2A |= (1 << COM2A1) | (1 << COM2B1) | (1 << WGM20) | (1 << WGM21);
		TCCR2B = (1 << WGM22) | (1 << CS22) | (1 << CS21) | (1 << CS20);
		OCR2B = 0;	//установка значения в регистр сравнения B
	}
	else
	{
		TCCR2A |= (1 << COM2A1) | (1 << COM2B1) | (1 << WGM20) | (1 << WGM21);
		TCCR2B = (1 << WGM22) | (1 << CS22) | (1 << CS21) | (1 << CS20);
		OCR2B = x/6; //установка значения в регистр сравнения B
	}
	x = 0x00;	//очистка переменной x
	
}
int main(void)	//главная процедура, точка входа в программу
{
	DDRD = 0xFC;	//установка на вход PORTD0 и PORTD1
	TCCR1A |= (1 << COM1A0) | (1 << COM1A1) | (0 << WGM11);	
	//инверсный режим вывода OC1A при совпадении
	TCCR1B |= (1 << WGM12) | (1 << CS12) | (0 << CS11) |(1 << CS10); 
	//управление режимов работы OC1A и OC1B и установка предделителя 1024
	TIMSK1 |= (1 << OCIE1A); //разрешение прерывания таймера 1
	OCR1A = 300;	//установка значения в регистр сравнения A
	//TIMER2(0)
	TCCR2A |= (1 << COM2A1) | (1 << COM2B1) | (1 << WGM20) | (1 << WGM21);
	//инверсный режим вывода OC2A при совпадении и режим ШИМ
	TCCR2B = (1 << WGM22) | (1 << CS22) | (1 << CS21) | (1 << CS20);
	//управление режимов работы OC2A и OC2B и установка предделителя 1024
	OCR2A = 255;	//установка значения в регистр сравнения A
	
	UBRR0 = 103; 	//скорость 9600бит/c при частоте генератора 16МГц
	UCSR0B |= (1<<RXEN0) | (1 << RXCIE0);//разрешение приёма данных и прерывания USART0_RX
	UCSR0C |= (1<<UCSZ01) | (1<<UCSZ00);//размер пакета 8бит
	sei();		//глобальные прерывания
	while (1)	//бесконечный цикл
	{	
		if (UDRE0 != 0)				//проверка на готовность приёма данных
		{
			x = UDR0;				//приём данных по UART в переменную x
		}
	}
}





