#include <avr/io.h>			//библиотека с логическими именами портов
#include <avr/interrupt.h>	//библиотека прерываний
unsigned char OVF_counter, zamer_1, zamer_T; //переменные счётчика переполнений, для выбора операции, для выбора подсчёта периода
unsigned long T, f;	//переменные для значения периода и частоты
unsigned int rising_1, rising_2;	//вспомогательные переменные для подсчёта периода
ISR(TIMER1_OVF_vect)	//прерывания таймера 1 по переполнению
{
	OVF_counter++; // Увеличиваем счетчик переполнений
}
ISR(TIMER1_CAPT_vect) //прерывание таймера 1 по захвату
{
	switch(zamer_1)
	{
		case 0: // Вычисляем период импульса
		switch(zamer_T)
		{
			case 0:
			rising_1 = ICR1; // Запоминаем значение счётчика
			OVF_counter = 0; // Обнуляем количество переполнений счётчика
			zamer_T = 1; // Переходим к следующему вычислению
			break;
			
			case 1:
			rising_2 = ICR1; // Запоминаем значение счётчика
			// Приводим все переменные к одному типу и вычисляем период импульса
			T = (unsigned long)rising_2 - (unsigned long)rising_1 + ((unsigned long)OVF_counter * 65536);
			zamer_T = 0;
			zamer_1 = 1; // Переходим к следующему вычислению
			break;
		}
		break;
		case 1:
		f = (16000000)/T; // Вычисляем частоту сигнала в Гц
		zamer_1 = 0; // Переходим к следующему вычислению
		if (UDRE0 != 0)	//проверка на готовность приёма данных
		{
			UDR0 = f/1000;	//вывод значения частоты в кГц по UART
		}
		break;
	}
};
ISR(ADC_vect){				//прерывание преобразования АЦП
	OCR0A = ADCH;			//уставнока значения в регистр стравнения A таймера 0 значения с АЦП
}
void timer0()	//функция для инициализации таймера 0
{
	DDRD = 0x40;	//функция инициализации UART
	TCCR0A |= (0 << COM0A1) | (1 << COM0A0) | (1 << WGM00) | (1 << WGM01);
	//Настройка TC0 в режиме ШИМ на выводе OC0A (не инверсный режим)
	TCCR0B |= (1 << WGM02) | (0 << CS02) | (1 << CS01) | (1 << CS00);	//запуск таймера с частотой Fclk/64
}
void uartic()			//функция инициализации UART
{
	UBRR0 = 103;		//главная процедура, точка входа в программу
	UCSR0C |= (1 << UCSZ01) | (1 << UCSZ00);//размер пакета 8бит
	UCSR0B |= (1 << TXEN0);	//разрешение передачи данных
}
void adc(){			//функция инициализации АЦП
	ADMUX = (0<<REFS1)|(1<<REFS0)|(1<<ADLAR)|(0<<MUX3)|(0<<MUX2)|(0<<MUX1)|(0<<MUX0);
	//вкл. ацп, реж. непрерывн. преобр., разр. прерывания, частота преобр. = FCPU/128
	ADCSRA = (1<<ADEN)|(1<<ADSC)|(1<<ADATE)|(1<<ADIE)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
}

void timer1(){		//функция для инициализации таймера 1
	TCCR1B |= (1 << ICES1) | (0 << CS12) | (0 << CS11) | (1 << CS10);
	//включение регистра захвата по фронту и Fclk/1
	TIMSK1 |= (1 << TOIE1) |(1 << ICIE1);	//разрешение прерывания захвата и прерывания по переполнению

}
int main(void)	//главная процедура, точка входа в программу
{
	timer0();	//вызов функции инициализации таймера 0
	uartic();	//вызов функции инициализации UART
	adc();		//вызов функции инициализации АЦП
	timer1();	//вызов функции инициализации таймера 1
	sei();		//разрешение глобальных прерываний
	while (1)	//бесконечный цикл
	{
	}
}