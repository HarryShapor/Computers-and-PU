#include <avr/io.h>	//библиотека с логическими именами портов 
#include <avr/interrupt.h>	//библиотека прерываний
uint16_t old; //глобальная переменная для хранения последнего значения захвата
ISR(TIMER1_CAPT_vect) //прерывание таймера 1 по захвату
{
	uint16_t temp = ICR1; //текущее значение захвата
	uint16_t delta = 0; //переменная для хранения разницы
	if (temp>old) //если текущее больше предыдущего
		delta = temp - old; //разница новое - старое
	else //иначе (таймер успел переполниться)
		delta = 65535 - old + temp; //разница 65635 - старое + новое
	if ((UCSR0A&(1<<UDRE0))!=0) //если UART не занят
		UDR0=delta; //отправка по UART
	old = temp; //сохранение нового значения
};
void timer0()	//функция для инициализации таймера 0
{
	DDRD = 0x40;	//инициализация PORTD6 на вывод
	TCCR0A |= (1 << COM0A1) | (1 << WGM00) | (1 << WGM01);
	//Настройка TC0 в режиме ШИМ на выводе OC0A (не инверсный режим)
	TCCR0B |= (1 << CS02) | (0 << CS01) | (0 << CS00);	//запуск таймера с частотой Fclk/256
	OCR0A = 127;	//установка регистра сравнения A (50% заполнения)
}
void uartic()		//функция инициализации UART
{
	UBRR0 = 103;	//скорость 9600бит/c при частоте генератора 16МГц
	UCSR0C |= (1 << UCSZ01) | (1 << UCSZ00);//размер пакета 8бит
	UCSR0B |= (1 << TXEN0);	//разрешение передачи данных
}
int main(void)	//главная процедура, точка входа в программу
{
	TCCR1B |= (1 << ICES1) | (1 << CS12) | (0 << CS11) | (1 << CS10);
	//запуск таймера с частотой Fclk/1024 и нарастающий фронт регистра захвата 
	TIMSK1 = (1 << ICIE1);	//разрешение прерывания захвата входа
	timer0();	//вызов функции инициализации таймера 0
	uartic();	//вызов функции инициализации UART
	sei();
	while (1)	//бесконечный цикл
	{
	}
}

