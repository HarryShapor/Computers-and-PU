#include <avr/io.h> //библиотека с логическими именами портов
#include <avr/interrupt.h>
uint16_t old; //глобальная переменная для хранения последнего значения захвата
ISR(TIMER1_CAPT_vect) //прерывание таймера 1 по захвату
{
	uint16_t temp = ICR1; //текущее значение захвата
	uint16_t delta = 0; //переменная для хранения разницы
	if (PORTB0 == 1)
	{
		TCCR1B = (0 << ICES1) | (1 << CS12) | (0 << CS11) | (0 << CS10);
		old = temp;
	}
	if (PORTB0 == 0)
	{
		TCCR1B = (1 << ICES1) | (1 << CS12) | (0 << CS11) | (0 << CS10);
		if (temp>old) //если текущее больше предыдущего
			delta = temp - old; //разница новое - старое
		else //иначе (таймер успел переполниться)
			delta = 65535 - old + temp; //разница 65635 - старое + новое
		if ((UCSR0A&(1<<UDRE0))!=0) //если UART не занят
			UDR0 = (343 * delta) / 2; //отправка по UART
		old = temp; //сохранение нового значения
	}
}
void timer0()		//функция для инициализации таймера 0
{
	TCCR0A |= (1 << COM0A1) | (0 << COM0A0) | (1 << COM0B1) | (1 << COM0B0)| (1 << WGM00) | (0 << WGM01);
	TCCR0B |= (0 << CS02) | (1 << CS01) | (0 << CS00); //запуск таймера с частотой Fclk/256
	TIMSK0 = (1 << OCIE0A) | (1 << OCIE0B);
	OCR0A = 255;	//установка регистра сравнения A (50% заполнения)
	OCR0B = 234;
}
void uartic()		//функция инициализации UART
{
	UBRR0 = 103;	//скорость 9600бит/c при частоте генератора 16МГц
	UCSR0C |= (1 << UCSZ01) | (1 << UCSZ00);//размер пакета 8бит
	UCSR0B |= (1 << TXEN0);	//разрешение передачи данных
}
ISR(TIMER0_COMPA_vect) {
	PORTB = (1 << PORTB1);
}
ISR(TIMER0_COMPB_vect) {
	PORTB = (0 << PORTB1);
}
int main(void)		//главная процедура, точка входа в программу
{
	DDRB = 0x02;
	TCCR1B = (1 << ICNC1) | (1 << ICES1) | (1 << CS12) | (0 << CS11) | (0 << CS10);
	//запуск таймера с частотой Fclk/1024 и нарастающий фронт регистра захвата
	TIMSK1 = (1 << ICIE1);	//разрешение прерывания захвата входа
	timer0();
	uartic();
	sei();
	while (1)		//бесконечный цикл
	{
	}
	
}


