#include <avr/io.h> //библиотека с логическими именами портов
#include <avr/interrupt.h>	//библиотека прерываний
uint16_t old; //глобальная переменная для хранения последнего значения захвата
ISR(TIMER1_CAPT_vect) //прерывание таймера 1 по захвату
{
	uint16_t temp = ICR1; //текущее значение захвата
	uint16_t delta = 0; //переменная для хранения разницы
	if (PORTB0 == 1)	//Если на линии ECHO 1
	{
		TCCR1B = (0 << ICES1) | (1 << CS12) | (0 << CS11) | (0 << CS10);
		//запуск таймера с частотой Fclk/256 и спадающий фронт регистра захвата
		old = temp;	//сохранение текущего времени в глобальную переменную
		TIMSK0 = (0 << OCIE0A) | (0 << OCIE0B); //запрет прерываний по совпадению с A и B
	}
	if (PORTB0 == 0)	//Если на линии ECHO 0
	{
		TCCR1B = (1 << ICES1) | (1 << CS12) | (0 << CS11) | (0 << CS10);
		//запуск таймера с частотой Fclk/256 и нарастающий фронт регистра захвата
		if (temp>old) //если текущее больше предыдущего
			delta = temp - old; //разница новое - старое
		else //иначе (таймер успел переполниться)
			delta = 65535 - old + temp; //разница 65635 - старое + новое
		if ((UCSR0A&(1<<UDRE0))!=0) //если UART не занят
			UDR0 = (343 * delta) / 2; //отправка по UART
			TIMSK0 = (1 << OCIE0A) | (1 << OCIE0B); //разрешение прерываний по совпадению с A и B
		old = temp; //сохранение нового значения
	}
}
void timer0()		//функция для инициализации таймера 0
{
	TCCR0A |= (1 << COM0A1) | (0 << COM0A0) | (1 << COM0B1) | (1 << COM0B0)| (1 << WGM00) | (0 << WGM01);
	//Настройка TC0 в режиме СТС, сброс вывода OC0A при совпадении с A и установка в 1 OC0B при совпадении с B
	TCCR0B |= (0 << CS02) | (1 << CS01) | (0 << CS00); //запуск таймера с частотой Fclk/8
	TIMSK0 = (1 << OCIE0A) | (1 << OCIE0B);		//разрешение прерываний по совпадению с A и B
	OCR0A = 255;	//установка значения в регистр сравнения A
	OCR0B = 234;	//установка значения в регистр сравнения B
}
void uartic()		//функция инициализации UART
{
	UBRR0 = 103;	//скорость 9600бит/c при частоте генератора 16МГц
	UCSR0C |= (1 << UCSZ01) | (1 << UCSZ00);//размер пакета 8бит
	UCSR0B |= (1 << TXEN0);	//разрешение передачи данных
}
ISR(TIMER0_COMPA_vect) {	//прерывания таймера 0 по совпадению с регистром сравнения A
	PORTB = (1 << PORTB1);	//установка значения 1 в PORTB1
}
ISR(TIMER0_COMPB_vect) {	//прерывания таймера 0 по совпадению с регистром сравнения B
	PORTB = (0 << PORTB1);	//установка значения 0 в PORTB1
}
int main(void)		//главная процедура, точка входа в программу
{
	DDRB = 0x02;	//инициализация на вывод порта PB1
	TCCR1B = (1 << ICES1) | (1 << CS12) | (0 << CS11) | (0 << CS10);
	//запуск таймера с частотой Fclk/256 и нарастающий фронт регистра захвата
	TIMSK1 = (1 << ICIE1);	//разрешение прерывания захвата входа
	timer0();		//инициализация Timer0
	uartic();		//инициализация UART
	sei();			//глобальные прерывания
	while (1)		//бесконечный цикл
	{
	}
	
}